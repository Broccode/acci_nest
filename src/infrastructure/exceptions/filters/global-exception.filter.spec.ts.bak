import { Test, TestingModule } from '@nestjs/testing';
import { GlobalExceptionFilter } from './global-exception.filter';
import { PinoLoggingServiceImpl } from '../../logging/services/pino-logging.service';
import { HttpAdapterHost } from '@nestjs/core';
import {
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import {
  BusinessRuleException,
  DomainException,
  EntityNotFoundException,
  UnauthorizedException,
  ValidationException,
} from '../exceptions';

// --- Mocks --- //
const mockPinoLoggingService = {
  error: jest.fn(),
  warn: jest.fn(),
  log: jest.fn(),
  info: jest.fn(),
  debug: jest.fn(),
  verbose: jest.fn(),
  fatal: jest.fn(),
  createChildLogger: jest.fn(),
  setContext: jest.fn(),
  pinoLogger: {
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn(),
  },
  // Zusätzliche Eigenschaften, die vom Typ benötigt werden
  logger: {},
  options: {},
  correlationService: {},
  tenantContext: {}
} as any; // Cast als any für den Test

const mockHttpAdapter = {
  reply: jest.fn(),
  getRequestUrl: jest.fn(),
  getRequestMethod: jest.fn(),
};

const mockHttpAdapterHost = {
  httpAdapter: mockHttpAdapter,
};

const mockGetResponse = () => ({
  status: jest.fn().mockReturnThis(),
  json: jest.fn(),
});

const mockGetRequest = (url: string = '/test') => ({
  url,
  headers: {
    'x-correlation-id': 'test-correlation-id'
  }
});

const mockHttpArgumentsHost = {
  getResponse: jest.fn(),
  getRequest: jest.fn(),
};

const mockArgumentsHost: ArgumentsHost = {
  switchToHttp: jest.fn().mockReturnValue(mockHttpArgumentsHost),
  getArgs: jest.fn(),
  getArgByIndex: jest.fn(),
  getType: jest.fn().mockReturnValue('http'), // Mock the type as http
  // Add missing methods required by ArgumentsHost interface
  switchToRpc: jest.fn(),
  switchToWs: jest.fn(),
};
// --- End Mocks --- //

describe('GlobalExceptionFilter', () => {
  let filter: GlobalExceptionFilter;

  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();

    // Setup mock implementations for ArgumentsHost
    mockHttpArgumentsHost.getResponse.mockImplementation(mockGetResponse);
    mockHttpArgumentsHost.getRequest.mockImplementation(mockGetRequest);
    
    // Direkt instanziieren statt durch NestJS DI
    filter = new GlobalExceptionFilter(
      mockPinoLoggingService
    );
  });

  it('should be defined', () => {
    expect(filter).toBeDefined();
  });

  // --- Test Cases for Different Exceptions --- //

  it('should handle HttpException', () => {
    const exception = new HttpException('Forbidden resource', HttpStatus.FORBIDDEN);
    const status = HttpStatus.FORBIDDEN;
    const requestUrl = '/forbidden';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String), // Context
      `HttpException: Forbidden resource Status: ${status}`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Forbidden resource',
        path: requestUrl,
        errorCode: 'HTTP_EXCEPTION',
        timestamp: expect.any(String),
      }),
      status
    );
  });

  it('should handle EntityNotFoundException', () => {
    const exception = new EntityNotFoundException('Item', 'abc');
    const status = HttpStatus.NOT_FOUND;
    const requestUrl = '/items/abc';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String),
      `DomainException: Entity 'Item' with id 'abc' not found Status: ${status} Code: ENTITY_NOT_FOUND`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: "Entity 'Item' with id 'abc' not found",
        path: requestUrl,
        errorCode: 'ENTITY_NOT_FOUND',
        timestamp: expect.any(String),
      }),
      status
    );
  });

  it('should handle ValidationException', () => {
    const errors = { email: ['invalid format'] };
    const exception = new ValidationException(errors);
    const status = HttpStatus.BAD_REQUEST;
    const requestUrl = '/register';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String),
      `DomainException: Validation failed Status: ${status} Code: VALIDATION_ERROR`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Validation failed',
        path: requestUrl,
        errorCode: 'VALIDATION_ERROR',
        errors: errors,
        timestamp: expect.any(String),
      }),
      status
    );
  });

 it('should handle UnauthorizedException', () => {
    const exception = new UnauthorizedException('Token expired');
    const status = HttpStatus.UNAUTHORIZED;
    const requestUrl = '/profile';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String),
      `DomainException: Token expired Status: ${status} Code: UNAUTHORIZED`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Token expired',
        path: requestUrl,
        errorCode: 'UNAUTHORIZED',
        timestamp: expect.any(String),
      }),
      status
    );
  });

  it('should handle BusinessRuleException', () => {
    const exception = new BusinessRuleException('Insufficient funds', 'INSUFFICIENT_FUNDS');
    const status = HttpStatus.UNPROCESSABLE_ENTITY;
    const requestUrl = '/purchase';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String),
      `DomainException: Insufficient funds Status: ${status} Code: INSUFFICIENT_FUNDS`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Insufficient funds',
        path: requestUrl,
        errorCode: 'INSUFFICIENT_FUNDS',
        timestamp: expect.any(String),
      }),
      status
    );
  });

  it('should handle generic DomainException with context', () => {
    const context = { orderId: 555 };
    const exception = new DomainException('Order processing failed', 'ORDER_FAIL', HttpStatus.BAD_REQUEST, context);
    const status = HttpStatus.BAD_REQUEST;
    const requestUrl = '/orders';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.warn).toHaveBeenCalledWith(
      expect.any(String),
      `DomainException: Order processing failed Status: ${status} Code: ORDER_FAIL`,
      exception.stack,
      context
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Order processing failed',
        path: requestUrl,
        errorCode: 'ORDER_FAIL',
        orderId: 555, // Context should be included
        timestamp: expect.any(String),
      }),
      status
    );
  });

  it('should handle unexpected Error', () => {
    const exception = new Error('Something broke!');
    const status = HttpStatus.INTERNAL_SERVER_ERROR;
    const requestUrl = '/unexpected';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    expect(mockPinoLoggingService.error).toHaveBeenCalledWith(
      expect.any(String), // Context
      `Unhandled Exception: Something broke!`,
      exception.stack
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Internal Server Error',
        path: requestUrl,
        errorCode: 'INTERNAL_SERVER_ERROR',
        timestamp: expect.any(String),
      }),
      status
    );
  });

 it('should handle non-Error exceptions', () => {
    const exception = 'this is just a string'; // Non-error type
    const status = HttpStatus.INTERNAL_SERVER_ERROR;
    const requestUrl = '/non-error';
    mockHttpArgumentsHost.getRequest.mockReturnValue(mockGetRequest(requestUrl));
    const mockResponse = mockGetResponse();
    mockHttpArgumentsHost.getResponse.mockReturnValue(mockResponse);

    filter.catch(exception, mockArgumentsHost);

    // Should still log as an error, including the raw exception object
    expect(mockPinoLoggingService.error).toHaveBeenCalledWith(
      expect.any(String),
      `Unhandled Exception: Non-Error thrown: ${JSON.stringify(exception)}`,
      'N/A' // No stack available
    );
    expect(mockHttpAdapter.reply).toHaveBeenCalledWith(
      mockResponse,
      expect.objectContaining({
        statusCode: status,
        message: 'Internal Server Error',
        path: requestUrl,
        errorCode: 'INTERNAL_SERVER_ERROR',
        timestamp: expect.any(String),
      }),
      status
    );
  });
}); 